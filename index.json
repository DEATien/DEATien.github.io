[{"categories":["tool"],"content":"安装Deatool 首先需要您电脑内装有Python，且版本号低于3.9 在CMD命令行输入： pip install deatool 由于需要安装相关依赖库，可能需要一段时间，请您耐心等待安装完成 在python环境下输入： import deatool deatool.run() 或者： from deatool import run run() 顺利的话将会出现如下Deatool图形交互界面： ","date":"2022-04-01","objectID":"/deatool/:0:1","tags":["Deatool"],"title":"Deatool使用指南","uri":"/deatool/"},{"categories":["tool"],"content":"Deatool功能介绍 恭喜您已经成功打开了Deatool，接下来将向您介绍这个Python库的功能： 计算CCR模型、BCC模型、SBM模型、DDF模型的效率值 针对以上模型可以选取不同的规模报酬性，分别是：CRS（constant returns to scale），VRS（variable returns to scale） 选择CCR模型，会自动输出CCR、BCC模型下的效率值，并判断规模报酬情况 针对DDF模型可以选取不同的方向并设置对非期望产出的处置性 针对SBM模型可以输出相应指标的改进量（投入冗余与产出不足） 可以处理包含非期望产出的模型 可以选取不同的主流处理器，目前支持：Gurobi，Cplex，Glpk，请根据您的求解器安装情况来选取求解器 ","date":"2022-04-01","objectID":"/deatool/:0:2","tags":["Deatool"],"title":"Deatool使用指南","uri":"/deatool/"},{"categories":["tool"],"content":"Deatool使用流程 点击“导入表格”(参考实例数据)，请注意表格的导入形式为： DMU名称 投入 产出 非期望产出 DMU1 xxx xxx xxx … … … … DMUn xxx xxx xxx 正确导入表格后，会在右边栏出现表格内容 选择需要测算模型，默认CCR模型 选择规模报酬性，默认CRS 如果选择是DDF模型，请选择合适的方向；若选择的是CCR或SBM模型，“请选择方向”一栏默认即可 填写投入变量的个数，如果有2个投入，请填写阿拉伯数字“2”，不要写多余的字 填写产出变量的个数，同上 填写非期望产出变量的个数，同上，需注意无非期望产出的话，默认即可 选择合适的求解器，默认为Gurobi 点击“开始计算”，右边栏出现计算过程信息 最下面出现计算结果的表格，点击“结果保存”，结果将会储存在与你导入数据的同一个文件夹内 简单操作演示  以SBM模型为例，数据同上，包含2个投入，3个期望产出，2个非期望产出： ","date":"2022-04-01","objectID":"/deatool/:0:3","tags":["Deatool"],"title":"Deatool使用指南","uri":"/deatool/"},{"categories":["tool"],"content":"Deatool注意事项 如果数据表格导入有误，将会出现“Error:数据读取有误，请检查数据”的字样，那么请您重新检查数据格式 数据正常导入后，点击’开始计算’后若出现“出错，请检查步骤是否正确”，那么请您检查是否按照上述步骤进行操作，可能的问题为变量个数填写错误或您的电脑内没有装您选取的求解器，请您重新选取求解器 建议您使用Gurobi求解器，求解速度最快 在导入数据后，您可以多次测算模型，并通过最下方查看计算的结果 如果您需要保存数据，请务必按下“结果保存”键，否则不会对结果进行保存 如果您在使用中出现了什么问题，请及时联系我的微信，也欢迎您对后续的功能进行建议 ","date":"2022-04-01","objectID":"/deatool/:0:4","tags":["Deatool"],"title":"Deatool使用指南","uri":"/deatool/"},{"categories":["tool"],"content":"Support or Contact  Wechat： yomamalielie ","date":"2022-04-01","objectID":"/deatool/:0:5","tags":["Deatool"],"title":"Deatool使用指南","uri":"/deatool/"},{"categories":["model"],"content":" 本文带你从零开始完成一个DEA模型的python代码 ","date":"2022-04-23","objectID":"/dea_code/:0:0","tags":["Paper"],"title":"手把手教你利用Python写DEA模型","uri":"/dea_code/"},{"categories":["model"],"content":"引言 恭喜你成为杜老师师门中的一员！  利用编程语言来实现DEA模型是每一个DEAer的必备技能，目前市面上有各类DEA计算效率的可视化软件，但是对于免费的软件，可实现的功能十分少，只能简单做CCR 或者 BCC模型，而对于付费的软件呢，又是十分地贵，只能实现主流的已有的模型。如果我们自己对现有的模型进行改动，用这些软件是无法实现的。 那么我们就十分有必要自己去实现DEA模型，因此本文将从零开始带你完成一个DEA模型的python代码。由于咱们师门的同学大部分都是利用Matlab+Yalmip+CPLEX来完成DEA模型的求解与建模，在此基础上，本文就直接借助CPLEX求解器结合Python语言来展开本教程。 如果你刚进师门的话，请点击一下该链接自行注册下载CPLEX学术版，点击这里，或者直接联系你的师兄师姐，让他们发送安装给你。 如果一切准备就绪的话，那让我们开始吧！ ","date":"2022-04-23","objectID":"/dea_code/:0:1","tags":["Paper"],"title":"手把手教你利用Python写DEA模型","uri":"/dea_code/"},{"categories":["model"],"content":"准备工作 Python的下载、安装与配置请大家自行搜索相关教程。 下载后Python后，你还需要安装一个代码编辑器来编写代码，主流的代码编辑器有很多，选择一款喜欢的即可。（例如pycharm等） 安装好后代码编辑器后，需要配置Python环境，网上相关教程有很多，这里也不展开介绍了。 打开系统的cmd窗口，在CMD命令行依次输入： pip install pandas ⇈ pandas提供了大量能使我们快速便捷地处理数据的函数和方法，我们主要利用pandas进行数据的读取与索引 pip install pyomo ⇈ 一个规划问题建模的python包，你可以理解为类似于yalmip pip install openpyxl ⇈ openpyxl主要是一个用来读写 Excel 2010 xlsx/xlsm/xltx/xltm 的 Python 库 5.准备工作就绪了之后，就可以开始我们的建模之路了。在此之前，还是希望同学们先掌握一些Python基本语法再食用本文，包含但不限于Python的基本语句、基本数据结构、函数、类与方法等知识。 ","date":"2022-04-23","objectID":"/dea_code/:0:2","tags":["Paper"],"title":"手把手教你利用Python写DEA模型","uri":"/dea_code/"},{"categories":["model"],"content":"模型构建 我们的实例数据为：参考实例数据，本文以较为实用的DDF模型为例进行建模，并以Python中函数的形式进行代码的编写，请将实例数据与该.py文件放在同一个文件夹中。 DDF模型 首先，我们给出弱可处置性与CRS假设下DDF模型的数学表达式： $$ \\begin{aligned} \\max \\beta \\\\ s.t. \u0026 \\sum_{j=1}^{n} \\lambda_{j} x_{i j} \\leq(1-\\beta) x_{i0}\\\\ \u0026 \\sum_{j=1}^{n} \\lambda_{j} y_{r j} \\geq(1+\\beta) x_{r0}\\\\ \u0026 \\sum_{j=1}^{n} \\lambda_{j} u_{t j} =(1-\\beta) u_{t0}\\\\ \u0026\\lambda \\geq 0 \\end{aligned} $$ 导入相关库 from pyomo.environ import * import pandas as pd 定义整体框架 数据的投入为：输入1，输入2；产出为：输出1，输出2，输出3；非期望产出为：非期望输出1，非期望输出2 首先读取相关数据： data =pd.read_excel('测试数据.xlsx') 定义投入产出及相关变量 Input = ['输入1','输入2'] Output = ['输出1','输出2','输出3'] Undesirable_Output =['非期望输出1','非期望输出2'] K = list(range(data.shape[0])) # K为data的行数，即代表DMU的个数。`list(range(data.shape[0]))`将其转换为列表形式，如果有5个DMU，则`K = [1,2,3,4,5]` 定义求解框架，总共有K个DMU，我们需要对这K个DMU进行循环求解，每次求解一个DMU，并记当前求解的DMU为i。在此之前，还需要定义一个TE空列表来储存将来的效率值。 TE = [] # 储存将来的效率值 for i in K: # 当前求解第i个决策单元 eff = DDFmodel(i, K, data, Input, Output, Undesirable_Output) TE.append(eff) # 记录每次求解的值 data['DDF效率'] = TE # data新增一列，记录为效率值 其中DDFmodel函数为下一节需要写的函数 综上所述，建立run()函数，返回值为data def run(): data =pd.read_excel('测试数据.xlsx') Input = ['输入1','输入2'] Output = ['输出1','输出2','输出3'] Undesirable_Output =['非期望输出1','非期望输出2'] K = list(range(data.shape[0])) TE = [] for i in K: eff = DDFmodel(i, K, data, Input, Output, Undesirable_Output) TE.append(eff) data['DDF效率'] = TE return data 定义DDF求解模型 本节将讲解DDFmodel函数的具体写法，首先我们通过运行run()函数，可以为DDFmodel函数传入i, K, data, Input, Output, Undesirable_Output的值，接下来将搭建模型。 创建求解环境 model = ConcreteModel() 创建决策变量 DDF模型的决策变量为: $\\lambda$与$\\beta$，取值范围为0到正无穷 $\\lambda \\geq 0$ model.lambdas = Var(K, within=NonNegativeReals) model.beta = Var(within=NonNegativeReals) 创建约束条件 DDF模型的约束条件为： $$ \\begin{aligned} \u0026 \\sum_{j=1}^{n} \\lambda_{j} x_{i j} \\leq(1-\\beta) x_{i0}\\\\ \u0026 \\sum_{j=1}^{n} \\lambda_{j} y_{r j} \\geq(1+\\beta) x_{r0}\\\\ \u0026 \\sum_{j=1}^{n} \\lambda_{j} u_{t j} =(1-\\beta) u_{t0}\\\\ \\end{aligned} $$ 以下代码与上述约束条件一一对应： model.constraints = ConstraintList() for p in Input: model.constraints.add(expr=sum(model.lambdas[j] * data.loc[j,p] for j in K) \u003c= (1-model.beta) * data.loc[i,p]) for q in Output: model.constraints.add(expr=sum(model.lambdas[j] * data.loc[j,q] for j in K) \u003e= (1+model.beta) * data.loc[i,q] ) for u in Undesirable_Output: model.constraints.add(expr=sum(model.lambdas[j] * data.loc[j,u] for j in K) == (1-model.beta) * data.loc[i,u]) 设置求解目标 目标函数为$max\\beta$ model.obj = Objective(expr=model.beta, sense=maximize) 设置求解参数 求解器选取为cplex，效率值为eff solver = SolverFactory('cplex') # 设定求解器 opt = solver.solve(model) # 进行求解 eff = value(model.obj) # 效率结果为目标函数值 综上所述，建立DDFmocel()函数，返回值为eff def DDFmodel(i, K, data,Input, Output, Undesirable_Output): model = ConcreteModel() model.lambdas = Var(K, within=NonNegativeReals) model.beta = Var(within=NonNegativeReals) model.constraints = ConstraintList() for p in Input: model.constraints.add(expr=sum(model.lambdas[j] * data.loc[j,p] for j in K) \u003c= (1-model.beta) * data.loc[i,p]) for q in Output: model.constraints.add(expr=sum(model.lambdas[j] * data.loc[j,q] for j in K) \u003e= (1+model.beta) * data.loc[i,q] ) for u in Undesirable_Output: model.constraints.add(expr=sum(model.lambdas[j] * data.loc[j,u] for j in K) == (1-model.beta) * data.loc[i,u]) model.obj = Objective(expr=model.beta, sense=maximize) solver = SolverFactory('cplex') opt = solver.solve(model) eff = value(model.obj) return eff 函数的进一步调用 我们已经搭建完成好了函数框架，接下来就是调用并储存结果了。 res = run() print(res) ## 显示最终结果 res.to_excel('Outputddf.xlsx') 我们也可以将数据储存为其他的数据格式，可以根据你的需求来储存在不同格式的文件中。 完整代码 是不是非常简单，我们已经完成了一个DDF模型的求解代码，以下为完整代码格式： from pyomo.environ import * import pandas as pd def run(): data =pd.read_excel('测试数据.xlsx') Input = ['输入1','输入2'] Output = ['输出1','输出2','输出3'] Undesirable_Output =['非期望输出1','非期望输出2'] K = list(range(data.shape[0])) TE = [] for i in K: eff = DDFmodel(i, K, data, Input, Output, Undesirable_Output) TE.append(eff) data['DDF效率'] = TE return data def DDFmodel(i, K, data,Input, Output, Undesirable_Output): model = ConcreteModel() model.lambdas = Var(K, within=NonNegativeReals) model","date":"2022-04-23","objectID":"/dea_code/:0:3","tags":["Paper"],"title":"手把手教你利用Python写DEA模型","uri":"/dea_code/"},{"categories":["model"],"content":"写在最后 按照这个顺序，相信你已经可以成功复现简单的DEA模型了，其他DEA模型可以采取相似的搭建方式。 本文是以函数的形式进行代码编写的，而一般来说，我会采用类与方法的形式来进行编写，这样会更方便。其次，Pyomo+CPLEX也并不是首选之举，我们也可以调用其他求解器或者调用其他包来书写代码，之后也会出相关进阶教程。 看完本文，有什么问题，或者代码出现了什么BUG，都欢迎及时来找我探讨。 ","date":"2022-04-23","objectID":"/dea_code/:0:4","tags":["Paper"],"title":"手把手教你利用Python写DEA模型","uri":"/dea_code/"},{"categories":["tool","model"],"content":"  本文将带您快速了解不同模型的形式 ","date":"2022-04-18","objectID":"/dea_model/:0:0","tags":["Deatool"],"title":"Deatool模型介绍","uri":"/dea_model/"},{"categories":["tool","model"],"content":"CCR模型 $$ \\begin{aligned} \\min \u0026 \\theta\\\\ s.t. \u0026 \\sum_{j=1}^{n} \\lambda_{j} x_{i j} \\leq \\theta x_{i 0} \\\\ \u0026 \\sum_{j=1}^{n} \\lambda_{j} y_{r j} \\geq y_{r 0} \\\\ \u0026 \\lambda_j \\geq 0 \\\\ \u0026 i=1,2 \\ldots, m ; r=1,2 \\ldots, q ; j=1,2 \\ldots, n \\end{aligned} $$ ","date":"2022-04-18","objectID":"/dea_model/:0:1","tags":["Deatool"],"title":"Deatool模型介绍","uri":"/dea_model/"},{"categories":["tool","model"],"content":"BCC模型 $$ \\begin{aligned} \\min \u0026 \\theta \\\\ s.t. \u0026 \\sum_{j=1}^{n} \\lambda_{j} x_{i j} \\leq \\theta x_{i 0} \\\\ \u0026 \\sum_{j=1}^{n} \\lambda_{j} y_{r j} \\geq y_{r 0} \\\\ \u0026 \\sum_{j=1}^{n} \\lambda_{j} = 1 \\\\ \u0026 \\lambda_j \\geq 0 \\\\ \u0026 i=1,2 \\ldots, m ; r=1,2 \\ldots, q ; j=1,2 \\ldots, n \\end{aligned} $$ ","date":"2022-04-18","objectID":"/dea_model/:0:2","tags":["Deatool"],"title":"Deatool模型介绍","uri":"/dea_model/"},{"categories":["tool","model"],"content":"SBM模型 $$ \\begin{aligned} \\min \u0026 \\rho=\\frac{1-\\frac{1}{m} \\sum_{i=1}^{m} s_{i}^{-} / x_{i 0}}{1+\\frac{1}{q} \\sum_{r=1}^{q} s_{r}^{+} / y_{r 0}} \\\\ s.t. \u0026 \\sum_{j=1}^{n} \\lambda_{j} x_{i j} + s_{i}^{-} = x_{i0} \\\\ \u0026 \\sum_{j=1}^{n} \\lambda_{j} y_{r j} - s_{i}^{+} = y_{r0} \\\\ \u0026\\lambda, s^{-}, s^{+} \\geq 0 \\end{aligned} $$   注：VRS假设下需要加入$\\sum_{j=1}^{n} \\lambda_{j} = 1$的约束条件 ","date":"2022-04-18","objectID":"/dea_model/:0:3","tags":["Deatool"],"title":"Deatool模型介绍","uri":"/dea_model/"},{"categories":["tool","model"],"content":"undesirable-SBM模型 $$ \\begin{aligned} \\min \u0026 \\rho=\\frac{1-\\frac{1}{m} \\sum_{i=1}^{m} s_{i}^{-} / x_{i 0}}{1+\\frac{1}{q_{1}+q_{2}}\\left(\\sum_{r=1}^{q_{1}} s_{r}^{+} / y_{r 0}+\\sum_{t=1}^{q_{2}} s_{t}^{u-} / u_{t 0}\\right)} \\\\ s.t. \u0026 \\sum_{j=1}^{n} \\lambda_{j} x_{i j} + s_{i}^{-} = x_{i0} \\\\ \u0026 \\sum_{j=1}^{n} \\lambda_{j} y_{r j} - s_{i}^{+} = y_{r0} \\\\ \u0026 \\sum_{j=1}^{n} \\lambda_{j} u_{t j} + s_{u-}^{+} = u_{t0} \\\\ \u0026\\lambda, s^{-},s^{u-},s^{+} \\geqslant 0 \\end{aligned} $$   注：VRS假设下需要加入$\\sum_{j=1}^{n} \\lambda_{j} = 1$的约束条件 ","date":"2022-04-18","objectID":"/dea_model/:0:4","tags":["Deatool"],"title":"Deatool模型介绍","uri":"/dea_model/"},{"categories":["tool","model"],"content":"DDF模型 $(-x,y,-b)$弱可处置性$=$ $$ \\begin{aligned} \\max \\beta \\\\ s.t. \u0026 \\sum_{j=1}^{n} \\lambda_{j} x_{i j} \\leq(1-\\beta) x_{i0}\\\\ \u0026 \\sum_{j=1}^{n} \\lambda_{j} y_{r j} \\geq(1+\\beta) x_{r0}\\\\ \u0026 \\sum_{j=1}^{n} \\lambda_{j} u_{t j} =(1-\\beta) u_{t0}\\\\ \u0026\\lambda \\geq 0 \\end{aligned} $$ $(-x,y,-b)$强可处置性$\\geq$ $$ \\begin{aligned} \\max \\beta \\\\ s.t. \u0026 \\sum_{j=1}^{n} \\lambda_{j} x_{i j} \\leq(1-\\beta) x_{i0}\\\\ \u0026 \\sum_{j=1}^{n} \\lambda_{j} y_{r j} \\geq(1+\\beta) x_{r0}\\\\ \u0026 \\sum_{j=1}^{n} \\lambda_{j} u_{t j} \\geq(1-\\beta) u_{t0}\\\\ \u0026\\lambda \\geq 0 \\end{aligned} $$ $(-x,y,-b)$强可处置性$\\leq$ $$ \\begin{aligned} \\max \\beta \\\\ s.t. \u0026 \\sum_{j=1}^{n} \\lambda_{j} x_{i j} \\leq(1-\\beta) x_{i0}\\\\ \u0026 \\sum_{j=1}^{n} \\lambda_{j} y_{r j} \\geq(1+\\beta) x_{r0}\\\\ \u0026 \\sum_{j=1}^{n} \\lambda_{j} u_{t j} \\leq(1-\\beta) u_{t0}\\\\ \u0026\\lambda \\geq 0 \\end{aligned} $$   注：VRS假设下需要加入$\\sum_{j=1}^{n} \\lambda_{j} = 1$的约束条件 ","date":"2022-04-18","objectID":"/dea_model/:0:5","tags":["Deatool"],"title":"Deatool模型介绍","uri":"/dea_model/"},{"categories":["tool","model"],"content":"Support or Contact  Wechat： yomamalielie ","date":"2022-04-18","objectID":"/dea_model/:0:6","tags":["Deatool"],"title":"Deatool模型介绍","uri":"/dea_model/"},{"categories":["model"],"content":" 本文将带您了解如何选取指标以及选取模型导向 ","date":"2022-04-19","objectID":"/dea_indicator/:0:0","tags":["Paper","index"],"title":"Dea模型指标、导向选取原则","uri":"/dea_indicator/"},{"categories":["model"],"content":"指标选取  很多同学在写论文的时候，都会纠结指标的选取，不清楚选择什么样的指标是比较合理的。一般来说，如果我们只需要得到一个集成指标来对所有指标进行集成/综合时，只需要满足投入和非期望产出越小越好，产出越多越好。但是如果对于一个实际问题而言，DEA模型的指标选取一般还需要满足以下规则  : DMU的数量至少应该为输入和输出指标之和数量的2-3倍，如果指标数较少的话，算出来的效率值结果往往不太好 需要进行相关性分析来验证输入和输出指标之间是否存在等渗关系，也就是说输入的一部分的增加是否增加了输出的一部分。可以采用Person相关性检验来看指标之间是否有正相关性。 Golany B, Roll Y. An application procedure for DEA[J]. Omega, 1989, 17(3): 237-250. 楚雪芹, 李勇军, 崔峰, 梁樑. 基于两阶段非期望DEA模型的商业银行效率评估[J]. 系统工程理论与实践, 2021, 41(03): 636-648. 如果从生产可能集的角度来考虑，投入指标和产出指标需要满足以下关系：x能生产y，y是由x生产出来的，指标的选取尽量需要包含多的生产要素 对于DEA模型，量纲一般是不影响结果的，但是在实际计算中，量纲过大，可能会导致产生错误的结果！这是由于求解器的精度所导致的，所以尽量还是保证量纲小一些，这点一定要注意 ","date":"2022-04-19","objectID":"/dea_indicator/:0:1","tags":["Paper","index"],"title":"Dea模型指标、导向选取原则","uri":"/dea_indicator/"},{"categories":["model"],"content":"导向选取  模型的导向的选择与你分析问题的目的有关 如果从管理角度来考虑的话，如果把减少投入作为对无效率单位提高效率的主要途径，则应该选取投入导向的模型；如果把增加产出作为对无效率单位提高效率的主要途径，则应该选取产出导向的模型 要结合实际情况来选取，如果在某种资源本身就不足的情况下，就不要选取投入导向的模型，因为这样的话，结果就不太好分析，如在整体资源不足的背景下仍需要一些DMU来缩减投入 现在用的较多的仍是SBM这类非径向无导向模型，即同时从投入不足与产出冗余来对结果进行考虑，具体选取什么模型还是依据分析的问题来定。 ","date":"2022-04-19","objectID":"/dea_indicator/:0:2","tags":["Paper","index"],"title":"Dea模型指标、导向选取原则","uri":"/dea_indicator/"},{"categories":["model"],"content":" 本文将带您了解生产中的规模问题  DEA模型中的规模报酬是老生常谈的话题了，那么什么是规模收益呢？读完以下文章，相信你一定会有一个清楚的认识。 ","date":"2022-04-19","objectID":"/dea_scale/:0:0","tags":["Paper"],"title":"Dea模型规模报酬的分析","uri":"/dea_scale/"},{"categories":["model"],"content":"生产函数中的规模报酬 什么是规模收益 规模收益要探讨的问题是：当所有投入要素的使用量都按同样的比例增加时，这种增加会对总产量有什么影响。假定 L单位的劳力和 K单位的资本结合可以生产 Q单位产品，即 L+K→Q。规模收益问题要探讨的是：如果 L和 K都增加 a倍，产量 Q将发生什么变化，即 aL+aK→？。 规模收益的三种类型 假定 aL+aK→bQ，那么，根据 b的值的大小，我们可以把规模收益分为三种类型。 第一种类型：b\u003ea，即产量增加的倍数，大于投入要素增加的倍数。譬如，人工和资本增加 1倍，能使产量增加 2倍。这种类型叫做规模收益递增（Increasing Return to Scale）。 第二种类型：b=a，即产量增加的倍数，等于投入要素增加的倍数。譬如，人工和资本增加1倍，产量也增加1倍。这种类型叫规模收益不变（Constant Return to Scale）。 第三种类型：b\u003ca，即产量增加的倍数，小于投入要素增加的倍数。譬如，人工和资本增加 2倍，却只能使产量增加 1倍。这种类型叫规模收益递减（Decreasing Return to Scale）。 当改变生产规模时，随着生产规模从小变大，一般会先后经历规模收益递增、不变和递减三个阶段。之所以会出现这样三个阶段，是因为在不同的阶段，有不同的因素在起作用。 规模收益变化在实际中的例子 促使规模收益递增的因素 如果原来生产规模较小，现在增加生产规模，这时会使规模收益递增。这是因为有以下因素在起作用。（1）工人可以专业化。在小企业中，一个工人可能要做好几种作业；在大企业中工人多，就可以分工分得更细，实行专业化。这样就有利于工人提高技术熟练程度，有利于提高劳动生产率。（2）可以使用专门化的设备和较先进的技术。小企业因为产量少，只能采用通用设备。大企业实行大量生产，有利于采用专用设备和较先进的技术。（3）大设备单位能力的制造和运转费用通常比小设备要低。例如，大高炉比小高炉、大型电机比小型电机单位能力的制造成本和运转成本要低。（4）生产要素具有不可分割性。例如，一座 1000吨的高炉，由于不可分割，除非产量达到1000吨，否则就不能充分利用。（5）其他因素。如大规模生产便于实行联合化和多种经营；便于实行大量销售和大量采购（可以节省购、销费用）；等等。 促使规模收益不变的因素 规模收益递增的趋势不可能是无限的，当生产达到一定规模之后，上述促使规模收益递增的因素会逐渐不再起作用。例如，工人分工如果过窄，就会导致工人工作单调，影响工人的积极性。设备生产率的提高，最终也要受当前技术水平的限制。所以，通常工厂总会有一个最优规模。对公司来说，当工厂达到最优规模时，再扩大生产，它就采用建若干个规模基本相同的工厂的办法。这时，规模收益基本处于不变阶段。这个阶段往往可以经历相当长一个时期，但最终它要进入规模收益递减阶段。 促使规模收益递减的因素 导致规模收益递减的因素主要是管理问题。企业规模越大，对企业各方面业务进行协调的难度也会越大。许多专家认为，由于高级经理人员很少接触基层，中间环节太多，就必然会造成文牍主义和官僚主义，使管理效率大大降低，这就促使规模收益递减。 以上内容选自智库， 相信大家已经了解了什么是规模报酬了。那么在DEA理论中，规模报酬应该如何判断呢，接下来让我们走进下一节。 ","date":"2022-04-19","objectID":"/dea_scale/:0:1","tags":["Paper"],"title":"Dea模型规模报酬的分析","uri":"/dea_scale/"},{"categories":["model"],"content":"DEA中规模报酬的判断方法  一般来说，在不同的生产规模下，规模报酬将会随之改变。我们是可以通过CRS模型的计算结果来判断所有决策单元所处的规模报酬情况的，具体而言： 生产规模小时，投入产出比会随着规模增加而迅速提升，称为规模报酬递增（lncreasing Returns to Scale, IRS） $\\sum_{j=1}^{n} \\lambda_{j} \\leq 1$，则该决策单元为\"规模报酬递增\" 当生产达到高峰期时，产出与规模成正比而达到最适生产规模，称为规模报酬固定（Constant Returns to Scale, CRS）； $\\sum_{j=1}^{n} \\lambda_{j} = 1$，则该决策单元为\"规模报酬不变\" 当生产规模过于庞大时，产出减缓，则称为规模报酬递减（Decreasing Returns to Scale, DRS），也就是投入增加时，产出增加的比例会少于投入增加的比例。 $\\sum_{j=1}^{n} \\lambda_{j} \\geq 1$，则该决策单元为\"规模报酬递减\"  由上可知，我们可以通过CRS模型来判断VRS模型中各个DMU所处的规模收益状态，但是需要注意的是，线性规划往往有多个最优解，所以对于某个DMU，$\\sum_{j=1}^{n} \\lambda_{j}$的值可能并不唯一。如果这样的话，按照上述方法就可能造成错误的判断。那么接下来引入一个新的判断方法： 如果规模效率\u003c1，并且在任一最优解中，$\\sum_{j=1}^{n} \\lambda_{j} \\leq 1$，则该决策单元为\"规模报酬递增\" 如果规模效率=1，则说明该决策单元为\"规模报酬不变\" 如果规模效率\u003c1，并且在任一最优解中，$\\sum_{j=1}^{n} \\lambda_{j} \\geq 1$，则该决策单元为\"规模报酬递减\" ","date":"2022-04-19","objectID":"/dea_scale/:0:2","tags":["Paper"],"title":"Dea模型规模报酬的分析","uri":"/dea_scale/"},{"categories":["model"],"content":"DEA中规模报酬的选择  如果在研究中，我们已经知道了哪些DMU处于什么阶段（IRS,CRS,DRS），那么我们就可以分别建立不同的模型（NDRS模型,CRS模型,NIRS模型）。但是在实际中，我们往往并不清楚DMU当前所处的规模报酬情况，所以一般选择VRS模型来计算效率值。 ","date":"2022-04-19","objectID":"/dea_scale/:0:3","tags":["Paper"],"title":"Dea模型规模报酬的分析","uri":"/dea_scale/"},{"categories":["model"],"content":" 本文带你走进Malmquist指数分解的相关术语 ","date":"2022-04-23","objectID":"/malmquist/:0:0","tags":["Paper"],"title":"Malmquist指数分析","uri":"/malmquist/"},{"categories":["model"],"content":"Malmquist指数概念介绍  Malmquist指数一般是分析面板数据的，涉及两个或更多时期的数据，每个 DMU 均有多个时期的投入和产出数值。但是如果把面板数据拆分成单个年份利用普通的DEA模型来逐年分析，分别得到每年的技术效率值，这是不合理的，因为技术会随着时间而发生变化，当技术进步是生产率提高的主要推动力的时候，只做技术效率分析是不全面的。  Malmquist 全要素生产率指数（Malmquist total factor productivity index，简称 MI）的概念最早源于 Malmquist (1953)，因此将这一类指数命名为 Malmquist 指数。不同类型的 Malmquist 指数，其区别仅仅是参比不同的前沿。   注意：计算 Malmquist 指数是可以采用不同的距离函数与DEA模型的，DEA 模型的选择与 Malmquist 指数类型的选择是相互独立的两个问题。有些文章一提到malmuqist指数就是默认为CCR模型，这是不正确的，Malmquist 指数只是提供了一种指数的表达式，具体的模型选取是自己定的。 ","date":"2022-04-23","objectID":"/malmquist/:0:1","tags":["Paper"],"title":"Malmquist指数分析","uri":"/malmquist/"},{"categories":["model"],"content":"Malmquist指数分解形式 effch代表技术效率变化 全称：technical efficiency change 简称：EC techch 代表技术进步/生产技术变化 全称：technological change 简称：TC pech代表纯技术效率变化 全称：pure efficiency change or pure technical efficiency change 简称：PEC sech代表规模效率变化 全称：scale-efficiency change 简称：SEC tfpch 代表全要素生产率变化，也就是malmuqist指数 全称：total factor productivity change 它们之间关系是： $effch=pech×sech$ $tfpch=effch×techch$ ","date":"2022-04-23","objectID":"/malmquist/:0:2","tags":["Paper"],"title":"Malmquist指数分析","uri":"/malmquist/"}]